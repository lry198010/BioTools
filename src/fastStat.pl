#!/usr/bin/perl -w
use strict;
use List::Util qw(sum min max);
use Getopt::Long;
use File::Basename;
use Data::Dumper;

my $fasta; # 
my $cluster; # cluster file generated by corset
my $statFile = "";
my $distFile = "";
my $minLen = 200;
my $group_len = 100;

my $As = 0;
my $Ts = 0;
my $Gs = 0;
my $Cs = 0;
my $Ns = 0;

# Parameter variables
my $helpAsked;

GetOptions(
  "i=s" => \$fasta,
  "c=s" => \$cluster,
  "h|help" => \$helpAsked,
  "s|statOutputFile=s" => \$statFile,
  "d|distOutputFile=s" => \$distFile,
  "m|minLenStat=i" => \$minLen,
  "g|groupLength=i" => \$group_len
);

if(defined($helpAsked)) {
  prtUsage();
  exit;
}

if(!defined($fasta)) {
  prtError("No input files are provided");
  exit(1);
}

if(not -f $fasta){
  prtError("file '$fasta' not exits");
  exit(1);
}

my ($fileName, $filePath) = fileparse($fasta);
$statFile = $fasta . "_n50_stat" if($statFile eq "");
$distFile = $fasta . "_dist" if($distFile eq "");

open(FI,$fasta) or die "Cann't open '$fasta' due to:$!\n";

my %seq;
my $nowSeqId="";
my $seq="";
while(my $txt = <FI>){
  if($txt !~ /^#/){
    $txt =~ s/^\s+//;
    $txt =~ s/\s+$//; 
    if($txt =~ /^>(\S+)/){
      if(length($seq) >= $minLen) {
        # $seq{$nowSeqId} = length($seq);
        $seq{$nowSeqId} = baseCount($seq);
      }
      $seq = "";
      $nowSeqId = $1;      
      if( defined $seq{$nowSeqId}){
        print STDERR "$nowSeqId is previous exist:$seq{$nowSeqId}\n";
      }
      #$seq{$nowSeqId} = 0;
    }else{
      $txt =~ s/\s//g;
      $seq .= $txt;
      #$seq{$nowSeqId} += length($txt);
    }
  }
}

if(length($seq) >= $minLen) {
  #$seq{$nowSeqId} = length($seq);
  $seq{$nowSeqId} = baseCount($seq);
  # baseCount($seq);
  #print STDERR Dumper(baseCount($seq));
}

close(FI);

# my @len = values %seq;
my @len = map {$_ ->[0];} values %seq;
(undef,$As, $Ts, $Gs, $Cs, $Ns) = baseCountByHash(%seq);
print STDERR join(",",($As, $Ts, $Gs, $Cs, $Ns)),"\n";
my $transcript_stat = printStat(@len);
print $transcript_stat,"\n";
print STDERR "Finished N50 Statisitcs output to file: $statFile\n";

my $groups = getGroupRange(0,1500,100);
my %groupCounts = printSeqLenGroup($groups,@len);
print STDERR Dumper(\%groupCounts);

printSeqLen($distFile,%seq);
print STDERR "Finished sequence length  output to file: $distFile\n";
print STDERR "ok finished\n";

sub printStat {
  my @len = @_; 

  my $totalReads = scalar @len;
  my $bases = sum(@len);
  my $minReadLen = min(@len);
  my $maxReadLen = max(@len);
  my $avgReadLen = sprintf "%0.2f", $bases/$totalReads;
  my $medianLen = calcMedian(@len);
  my $n05 = calcN50(\@len, 5);
  my $n10 = calcN50(\@len, 10);
  my $n25 = calcN50(\@len, 25);
  my $n50 = calcN50(\@len, 50);
  my $n75 = calcN50(\@len, 75);
  my $n90 = calcN50(\@len, 90);
  my $n95 = calcN50(\@len, 95);

  my $statStr = "#only length >= $minLen used\n";

  $statStr .= sprintf("%-25s %d\n" , "Total sequences", $totalReads);
  $statStr .= sprintf("%-25s %d\n" , "Total bases", $bases);
  $statStr .= sprintf("%-25s %d\n" , "Min sequence length", $minReadLen);
  $statStr .= sprintf("%-25s %d\n" , "Max sequence length", $maxReadLen);
  $statStr .= sprintf("%-25s %0.2f\n", "Average sequence length", $avgReadLen);
  $statStr .= sprintf("%-25s %0.2f\n", "Median sequence length", $medianLen);
  $statStr .= sprintf("%-25s %d\n", "N05 length", $n05);
  $statStr .= sprintf("%-25s %d\n", "N10 length", $n10);
  $statStr .= sprintf("%-25s %d\n", "N25 length", $n25);
  $statStr .= sprintf("%-25s %d\n", "N50 length", $n50);
  $statStr .= sprintf("%-25s %d\n", "N75 length", $n75);
  $statStr .= sprintf("%-25s %d\n", "N90 length", $n90);
  $statStr .= sprintf("%-25s %d\n", "N95 length", $n95);
  $statStr .= sprintf("%-25s %0.2f %s\n", "As", $As/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "Ts", $Ts/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "Gs", $Gs/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "Cs", $Cs/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "(A + T)s", ($As+$Ts)/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "(G + C)s", ($Gs+$Cs)/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "Ns", $Ns/$bases*100, "%");

  return $statStr;
  # close(O);
}

sub printSeqLenGroup {
  my $groupRange = shift;
  my @len = @_;
  
  my %groupCounts;
  foreach my $g (@$groupRange) {
    $groupCounts{join(",",@$g)} = 0;
  }

  foreach my $l (@len){
    foreach my $g (@$groupRange){
      if(($l >= $g->[0]) && ($l < $g->[1])){
         $groupCounts{join(",",@$g)}++;
         last;
      }
    }
  } 
  return %groupCounts;
}

sub getGroupRange {
  my $from = shift;
  my $to = shift;
  my $step = shift;
  
  my @groupRange;
  while($from < $to) {
    push @groupRange,[$from,$from + $step];
    $from += $step;
  }
  push @groupRange, [$from, 1000000000];
  return [@groupRange];
} 

sub printSeqLen {
  my $toFile = shift;
  my @seq = @_;
  
  print $toFile,"\n";

  open(O, ">$toFile") or die "Can not open file: $toFile\n";
  print O "#only length >= $minLen used\n\n";
  foreach my $k (keys %seq){
    print O "$k\t$seq{$k}->[0]\n";
  }
  close(O);
}

sub calcN50 {
  my @x = @{$_[0]};
  my $n = $_[1];
  @x=sort{$b<=>$a} @x;
  my $total = sum(@x);
  my ($count, $n50)=(0,0);
  for (my $j=0; $j<@x; $j++){
    $count+=$x[$j];
    if(($count>=$total*$n/100)){
      $n50=$x[$j];
      last;
    }
  }
  return $n50;
}

sub calcMedian {
  my @arr = @_;
  my @sArr = sort{$a<=>$b} @arr;
  my $arrLen = @arr;
  my $median;
  if($arrLen % 2 == 0) {
    $median = ($sArr[$arrLen/2-1] + $sArr[$arrLen/2])/2;
  }else{
    $median = $sArr[$arrLen/2];
  }
  return $median;
}

sub baseCount {
  my $seq = $_[0];
  my $tBs = length($seq); # total bases of the sequence
  my $tAs += $seq =~ s/A//gi;
  my $tTs += $seq =~ s/T//gi;
  my $tGs += $seq =~ s/G//gi;
  my $tCs += $seq =~ s/C//gi;
  my $tNs = length($seq);
  #$Ns += (length $seq) - $tAs - $tTs - $tGs - $tCs;
  #$Ns += (length $seq);# - $tAs - $tTs - $tGs - $tCs;
  #$Ns += $tNs;# - $tAs - $tTs - $tGs - $tCs;
  #$As += $tAs;
  #$Ts += $tTs;
  #$Gs += $tGs;
  #$Cs += $tCs;
  return [$tBs,$tAs,$tTs,$tGs,$tCs,$tNs];
}

sub baseCountByHash {
  my %seq = @_;
  
  # Bs = Total Bases
  my ($Bs, $As, $Ts, $Gs, $Cs, $Ns) = (0, 0, 0, 0, 0, 0);
  foreach my $v (values(%seq)){
    $Bs += $v->[0];
    $As += $v->[1];
    $Ts += $v->[2];
    $Gs += $v->[3];
    $Cs += $v->[4];
    $Ns += $v->[5];
  }
  return($Bs, $As, $Ts, $Gs, $Cs, $Ns)
}

sub prtHelp {
  print "\nperl $0 options:\n\n";
  print STDERR "### Input reads/sequences (FASTA) (Required)\n";
  print STDERR "  -i <Read/Sequence file>\n";
  print STDERR "    Read/Sequence in fasta format\n";
  print STDERR "  -c [cluster file]\n";
  print STDERR "    cluster file generated by corset\n";
  print STDERR "  -m <Min Sequence Length to Stat:200>\n";
  print STDERR "    Min Sequnece Length used in Stat\n";
  print STDERR "  -g <step length used to group the sequence:100>\n";
  print STDERR "    step length used to group the sequence\n";
  print STDERR "\n";
  print STDERR "### Other options [Optional]\n";
  print STDERR "  -h | -help\n";
  print STDERR "    Prints this help\n";
  print STDERR "  -s | -statOutputFile <Output file name>\n";
  print STDERR "    N50 output will be stored in the given file\n";
  print STDERR "    default: By default, N50 statistics file will be stored where the input file is\n";
  print STDERR "  -d | -distOutputFile <Output file name>\n";
  print STDERR "    Sequence length output will be stored in the given file\n";
  print STDERR "    default: By default, Sequence length file will be stored where the input file is\n";
  print STDERR "\n";
}

sub prtError {
  my $msg = $_[0];
  print STDERR "+======================================================================+\n";
  printf STDERR "|%-70s|\n", "  Error:";
  printf STDERR "|%-70s|\n", "       $msg";
  print STDERR "+======================================================================+\n";
  prtUsage();
  exit;
}

sub prtUsage {
  print STDERR "\nUsage: perl $0 <options>\n";
  prtHelp();
}
