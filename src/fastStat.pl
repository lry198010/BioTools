#!/usr/bin/perl -w
use strict;
use List::Util qw(sum min max);
use Getopt::Long;
use File::Basename;
use Data::Dumper;

my $fasta; # 
my $cluster; # cluster file generated by corset
my $fileBase = "";
my $minLen = 200;
my $group_len = 100;

my $As = 0;
my $Ts = 0;
my $Gs = 0;
my $Cs = 0;
my $Ns = 0;

# Parameter variables
my $helpAsked;

GetOptions(
  "i=s" => \$fasta,
  "c=s" => \$cluster,
  "h|help" => \$helpAsked,
  "f|filebase=s" => \$fileBase,
  "m|minLenStat=i" => \$minLen,
  "g|groupLength=i" => \$group_len
);

if(defined($helpAsked)) {
  prtUsage();
  exit;
}

if(!defined($fasta)) {
  prtError("No input files are provided");
  exit(1);
}

if(not -f $fasta){
  prtError("file '$fasta' not exits");
  exit(1);
}

my ($fileName, $filePath) = fileparse($fasta);
$fileName =~ s/\.[^\.]*$//;
$fileBase = $fileName if $fileBase eq "";

print STDERR "Note: Output filebaseName:$fileBase\n";

open(FI,$fasta) or die "Cann't open '$fasta' due to:$!\n";

my %seq;
my $nowSeqId="";
my $seq="";
while(my $txt = <FI>){
  if($txt !~ /^#/){
    $txt =~ s/^\s+//;
    $txt =~ s/\s+$//; 
    if($txt =~ /^>(\S+)/){
      if(length($seq) >= $minLen) {
        $seq{$nowSeqId} = baseCount($seq);
      }
      $seq = "";
      $nowSeqId = $1;      
      if( defined $seq{$nowSeqId}){
        print STDERR "$nowSeqId is previous exist:$seq{$nowSeqId}\n";
      }
    }else{
      $txt =~ s/\s//g;
      $seq .= $txt;
    }
  }
}

if(length($seq) >= $minLen) {
  $seq{$nowSeqId} = baseCount($seq);
}

close(FI);

# my @len = values %seq;
my @len = map {$_ ->[0];} values %seq;
(undef,$As, $Ts, $Gs, $Cs, $Ns) = baseCountByHash(%seq);
my $transcript_stat = printStat([$As, $Ts, $Gs, $Cs, $Ns],@len);
open(OUT,">$fileBase.trans.stat") or die "Cann't open trans.stat file '$fileBase.trans.stat':$!\n";
  print OUT $transcript_stat,"\n";
close(OUT);
print STDERR "Transcripts: Statisitcs output to file: $fileBase.trans.stat\n";

my $groups = getGroupRange(0,1500,100);
my %groupCounts = printSeqLenGroup($groups,@len);
open(OUT,">$fileBase.trans.groups") or die "Cann't open trans.groups file '$fileBase.trans.groups':$!\n";
  foreach my $g (sort {$a<=>$b} keys %groupCounts) {
    print OUT "[", join("):",@{$groupCounts{$g}}),"\n";
  }
close(OUT);
print STDERR "Transcripts: Groups output to file: $fileBase.trans.groups\n";

printSeqLen($fileBase . ".trans.len",{"minLen"=>$minLen,"fields"=>[0,1,2,3,4,5]},%seq);
print STDERR "Transcripts: Sequence length output to file:" . $fileBase . ".trans.len\n";

my %trinityGenes = TrinityGene(%seq);

@len = map {$_ ->[0];} values %trinityGenes;
(undef,$As, $Ts, $Gs, $Cs, $Ns) = baseCountByHash(%trinityGenes);
my $trinityGenes_stat = printStat([$As, $Ts, $Gs, $Cs, $Ns],@len);
open(OUT,">$fileBase.trigene.stat") or die "Cann't open trigene.stat file '$fileBase.trigene.stat':$!\n";
  print OUT $trinityGenes_stat,"\n";
close(OUT);
print STDERR "Trinity Genes: Statisitcs output to file: $fileBase.trigene.stat\n";


$groups = getGroupRange(0,1500,100);
%groupCounts = printSeqLenGroup($groups,@len);
open(OUT,">$fileBase.trigene.groups") or die "Cann't open trigene.groups file '$fileBase.trigene.groups':$!\n";
foreach my $g (sort {$a<=>$b} keys %groupCounts) {
  print OUT "[", join("):",@{$groupCounts{$g}}),"\n";
}
close(OUT);
print STDERR "Trinity Genes: Groups output to file: $fileBase.trigene.groups\n";

printSeqLen($fileBase . ".trigene.len",{"minLen"=>$minLen,"fields"=>[0,1,2,3,4,5,6,7,8]},%trinityGenes);
print STDERR "Trinity Genes: Sequence length output to file: $fileBase.trigene.len\n";

%trinityGenes = genes2trans("Trinity genes",%trinityGenes);

if (!defined($cluster)) {
  print STDERR "Note: no cluster file assigned\n";
  exit(0);
}

if(not -f $cluster){
  prtError("Error: cluster file '$cluster' not exits");
  exit(1);
}

my %corsetGenes = corsetGenes($cluster,%seq);
@len = map {$_ ->[0];} values %corsetGenes;
(undef,$As, $Ts, $Gs, $Cs, $Ns) = baseCountByHash(%corsetGenes);
my $corsetGenes_stat = printStat([$As, $Ts, $Gs, $Cs, $Ns],@len);
open(OUT,">$fileBase.corgene.stat") or die "Cann't open corgene.stat file '$fileBase.corgene.stat':$!\n";
print OUT $corsetGenes_stat,"\n";
close(OUT);
print STDERR "Corset Genes[Unigenes]: Statisitcs output to file: $fileBase.corgene.stat\n";


$groups = getGroupRange(0,1500,100);
%groupCounts = printSeqLenGroup($groups,@len);
open(OUT,">$fileBase.corgene.groups") or die "Cann't open corgene.groups file '$fileBase.corgene.groups':$!\n";
foreach my $g (sort {$a<=>$b} keys %groupCounts) {
  print OUT "[", join("):",@{$groupCounts{$g}}),"\n";
}
close(OUT);
print STDERR "Corset Genes[Unigenes]: Groups output to file: $fileBase.corgene.groups\n";

printSeqLen($fileBase . ".corgene.len",{"minLen"=>$minLen,"fields"=>[0,1,2,3,4,5,6,7,8]},%corsetGenes);
print STDERR "Trinity Genes: Sequence length output to file: $fileBase.corgene.len\n";


%corsetGenes = genes2trans("Trinity genes",%corsetGenes);

print STDERR "Trinity Genes: Sequence output to file: $fileBase.trigene.fa\n";
print STDERR "Trinity Genes: Sequence output to file: $fileBase.corgene.fa\n";

open(TRIOUT,">$fileBase.trigene.fa") or die "Cann't open trigene.fa '$fileBase.trigene.fa':$!\n";
open(COROUT,">$fileBase.corgene.fa") or die "Cann't open trigene.fa '$fileBase.trigene.fa':$!\n";

open(FI,$fasta) or die "Cann't open '$fasta' due to:$!\n";

my $seqDesc = "";
$nowSeqId="";
$seq="";
while(my $txt = <FI>){
  if($txt !~ /^#/){
    $txt =~ s/^\s+//;
    $txt =~ s/\s+$//; 
    if($txt =~ /^>(\S+)/){
      if (defined $trinityGenes{$nowSeqId}){
        print TRIOUT ">",$trinityGenes{$nowSeqId}," $nowSeqId $seqDesc\n";
        print TRIOUT $seq,"\n";
      }
      if (defined $corsetGenes{$nowSeqId}){
        print COROUT ">",$corsetGenes{$nowSeqId}," $nowSeqId $seqDesc\n";
        print COROUT $seq,"\n";
      }
      $seq = "";
      $nowSeqId = $1;      
      $seqDesc = $txt;
      $seqDesc =~ s/>//g;
    }else{
      $txt =~ s/\s//g;
      $seq .= $txt;
    }
  }
}

if (defined $trinityGenes{$nowSeqId}){
   print TRIOUT ">",$trinityGenes{$nowSeqId}," $nowSeqId $seqDesc\n";
   print TRIOUT $seq,"\n";
}
if (defined $corsetGenes{$nowSeqId}){
   print COROUT ">",$corsetGenes{$nowSeqId}," $nowSeqId $seqDesc\n";
   print COROUT $seq,"\n";
}

close(TRIOUT);
close(COROUT);
close(FI);

print STDERR "ok finished\n";

sub printStat {
  my $ATGCN = shift;
  my @len = @_; 

  my ($As, $Ts, $Gs, $Cs, $Ns) = @$ATGCN;
  my $totalReads = scalar @len;
  my $bases = sum(@len);
  my $minReadLen = min(@len);
  my $maxReadLen = max(@len);
  my $avgReadLen = sprintf "%0.2f", $bases/$totalReads;
  my $medianLen = calcMedian(@len);
  my $n05 = calcN50(\@len, 5);
  my $n10 = calcN50(\@len, 10);
  my $n25 = calcN50(\@len, 25);
  my $n50 = calcN50(\@len, 50);
  my $n75 = calcN50(\@len, 75);
  my $n90 = calcN50(\@len, 90);
  my $n95 = calcN50(\@len, 95);

  my $statStr = "#only length >= $minLen used\n";

  $statStr .= sprintf("%-25s %d\n" , "Total sequences", $totalReads);
  $statStr .= sprintf("%-25s %d\n" , "Total bases", $bases);
  $statStr .= sprintf("%-25s %d\n" , "Min sequence length", $minReadLen);
  $statStr .= sprintf("%-25s %d\n" , "Max sequence length", $maxReadLen);
  $statStr .= sprintf("%-25s %0.2f\n", "Average sequence length", $avgReadLen);
  $statStr .= sprintf("%-25s %0.2f\n", "Median sequence length", $medianLen);
  $statStr .= sprintf("%-25s %d\n", "N05 length", $n05);
  $statStr .= sprintf("%-25s %d\n", "N10 length", $n10);
  $statStr .= sprintf("%-25s %d\n", "N25 length", $n25);
  $statStr .= sprintf("%-25s %d\n", "N50 length", $n50);
  $statStr .= sprintf("%-25s %d\n", "N75 length", $n75);
  $statStr .= sprintf("%-25s %d\n", "N90 length", $n90);
  $statStr .= sprintf("%-25s %d\n", "N95 length", $n95);
  $statStr .= sprintf("%-25s %0.2f %s\n", "As", $As/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "Ts", $Ts/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "Gs", $Gs/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "Cs", $Cs/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "(A + T)s", ($As+$Ts)/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "(G + C)s", ($Gs+$Cs)/$bases*100, "%");
  $statStr .= sprintf("%-25s %0.2f %s\n", "Ns", $Ns/$bases*100, "%");

  return $statStr;
  # close(O);
}

sub printSeqLenGroup {
  my $groupRange = shift;
  my @len = @_;
  
  my %groupCounts;
  foreach my $g (@$groupRange) {
    $groupCounts{$g->[0]} = [join(",",@$g),0];
  }

  foreach my $l (@len){
    foreach my $g (@$groupRange){
      if(($l >= $g->[0]) && ($l < $g->[1])){
         $groupCounts{$g->[0]}->[1]++;
         last;
      }
    }
  } 
  return %groupCounts;
}

sub getGroupRange {
  my $from = shift;
  my $to = shift;
  my $step = shift;
  
  my @groupRange;
  while($from < $to) {
    push @groupRange,[$from,$from + $step];
    $from += $step;
  }
  push @groupRange, [$from, 1000000000];
  return [@groupRange];
} 

sub printSeqLen {
  my $toFile = shift;
  my $options = shift;
  my %seq = @_;
  
  my $sep = "\t";
  
  my $minLen = "null";
  $minLen = $options->{"minLen"};

  open(O, ">$toFile") or die "Can not open file: $toFile\n";
    print O "#only length >= $minLen used\n\n";
    foreach my $k (sort keys %seq){
      my @fields = ($k);
      foreach my $f (@{$options->{"fields"}}) {
        if (ref($seq{$k}->[$f]) eq "ARRAY") {
          push @fields,@{$seq{$k}->[$f]}; 
        }else{
          push @fields,$seq{$k}->[$f]; 
        }
      }
      print O join($sep,@fields),"\n";
    }
  close(O);
}

# T01_DN5152_c0_g1_i1
#   0    1    2    3    4    5
# ($Bs, $As, $Ts, $Gs, $Cs, $Ns)
sub TrinityGene {
  my %seq = @_;
  
  my %genes; 
  foreach my $seqId (keys %seq){
    my $geneId = $seqId;
    if ($seqId =~ /(.*)_i\d+$/){
      $geneId = $1;
    }
    if (defined $genes{$geneId}) {
      if ($genes{$geneId}->[0] < $seq{$seqId}->[0]) {
        $genes{$geneId}->[0] = $seq{$seqId}->[0];
        $genes{$geneId}->[1] = $seq{$seqId}->[1];
        $genes{$geneId}->[2] = $seq{$seqId}->[2];
        $genes{$geneId}->[3] = $seq{$seqId}->[3];
        $genes{$geneId}->[4] = $seq{$seqId}->[4];
        $genes{$geneId}->[5] = $seq{$seqId}->[5];
        $genes{$geneId}->[7] = $seqId;
      }
      $genes{$geneId}->[6]++;
      $genes{$geneId}->[8]->[0] += $seq{$seqId}->[0];
      $genes{$geneId}->[8]->[1] += $seq{$seqId}->[1];
      $genes{$geneId}->[8]->[2] += $seq{$seqId}->[2];
      $genes{$geneId}->[8]->[3] += $seq{$seqId}->[3];
      $genes{$geneId}->[8]->[4] += $seq{$seqId}->[4];
      $genes{$geneId}->[8]->[5] += $seq{$seqId}->[5];
    }else{
      $genes{$geneId}->[0] = $seq{$seqId}->[0];
      $genes{$geneId}->[1] = $seq{$seqId}->[1];
      $genes{$geneId}->[2] = $seq{$seqId}->[2];
      $genes{$geneId}->[3] = $seq{$seqId}->[3];
      $genes{$geneId}->[4] = $seq{$seqId}->[4];
      $genes{$geneId}->[5] = $seq{$seqId}->[5];
      $genes{$geneId}->[6] = 1;
      $genes{$geneId}->[7] = $seqId;
      $genes{$geneId}->[8] = [@{$seq{$seqId}}];
    }
  } 
  
  return %genes;
}

sub corsetGenes {
  my $clusterFile = shift;
  my %seq = @_;
  
  my %genes;

  open(IN,$clusterFile) or die "cann't open cluster file '$clusterFile':$!\n";
    while (my $txt = <IN>) {
      $txt =~ s/^\s+//;
      $txt =~ s/\s+$//;
      if ($txt !~ /^#/) {
        if ($txt =~ /(.+)\s+(.+)/) {
           my $geneId = $2;
           my $seqId = $1;
           if (defined $genes{$geneId}) {
             if ($genes{$geneId}->[0] < $seq{$seqId}->[0]) {
                $genes{$geneId}->[0] = $seq{$seqId}->[0];
                $genes{$geneId}->[1] = $seq{$seqId}->[1];
                $genes{$geneId}->[2] = $seq{$seqId}->[2];
                $genes{$geneId}->[3] = $seq{$seqId}->[3];
                $genes{$geneId}->[4] = $seq{$seqId}->[4];
                $genes{$geneId}->[5] = $seq{$seqId}->[5];
                $genes{$geneId}->[7] = $seqId;
             }
             $genes{$geneId}->[6]++;
             $genes{$geneId}->[8]->[0] += $seq{$seqId}->[0];
             $genes{$geneId}->[8]->[1] += $seq{$seqId}->[1];
             $genes{$geneId}->[8]->[2] += $seq{$seqId}->[2];
             $genes{$geneId}->[8]->[3] += $seq{$seqId}->[3];
             $genes{$geneId}->[8]->[4] += $seq{$seqId}->[4];
             $genes{$geneId}->[8]->[5] += $seq{$seqId}->[5];
           }else{
             $genes{$geneId}->[0] = $seq{$seqId}->[0];
             $genes{$geneId}->[1] = $seq{$seqId}->[1];
             $genes{$geneId}->[2] = $seq{$seqId}->[2];
             $genes{$geneId}->[3] = $seq{$seqId}->[3];
             $genes{$geneId}->[4] = $seq{$seqId}->[4];
             $genes{$geneId}->[5] = $seq{$seqId}->[5];
             $genes{$geneId}->[6] = 1;
             $genes{$geneId}->[7] = $seqId;
             $genes{$geneId}->[8] = [@{$seq{$seqId}}];
           }
        }else{
          print STDERR "Warning: corset format incorrect,'$txt'\n";
        }
      }
    }  
  close(IN);
  return %genes;
}

sub genes2trans {
  my $type = shift;
  my %genes = @_;
  
  my %genes2trans;
  
  foreach my $g (keys %genes) {
    if(defined $genes2trans{$genes{$g}->[7]}) {
      print STDERR "$type: represent genes dupulicated, $g -> $genes{$g}->[7] -> $genes2trans{$genes{$g}->[7]}\n";
    }else{
      $genes2trans{$genes{$g}->[7]} = $g;
    }
  }
  
  return %genes2trans;
}

sub calcN50 {
  my @x = @{$_[0]};
  my $n = $_[1];
  @x=sort{$b<=>$a} @x;
  my $total = sum(@x);
  my ($count, $n50)=(0,0);
  for (my $j=0; $j<@x; $j++){
    $count+=$x[$j];
    if(($count>=$total*$n/100)){
      $n50=$x[$j];
      last;
    }
  }
  return $n50;
}

sub calcMedian {
  my @arr = @_;
  my @sArr = sort{$a<=>$b} @arr;
  my $arrLen = @arr;
  my $median;
  if($arrLen % 2 == 0) {
    $median = ($sArr[$arrLen/2-1] + $sArr[$arrLen/2])/2;
  }else{
    $median = $sArr[$arrLen/2];
  }
  return $median;
}

sub baseCount {
  my $seq = $_[0];
  my $tBs = length($seq); # total bases of the sequence
  my $tAs += $seq =~ s/A//gi;
  my $tTs += $seq =~ s/T//gi;
  my $tGs += $seq =~ s/G//gi;
  my $tCs += $seq =~ s/C//gi;
  my $tNs = length($seq);
  #$Ns += (length $seq) - $tAs - $tTs - $tGs - $tCs;
  #$Ns += (length $seq);# - $tAs - $tTs - $tGs - $tCs;
  #$Ns += $tNs;# - $tAs - $tTs - $tGs - $tCs;
  #$As += $tAs;
  #$Ts += $tTs;
  #$Gs += $tGs;
  #$Cs += $tCs;
  return [$tBs,$tAs,$tTs,$tGs,$tCs,$tNs];
}

sub baseCountByHash {
  my %seq = @_;
  
  # Bs = Total Bases
  my ($Bs, $As, $Ts, $Gs, $Cs, $Ns) = (0, 0, 0, 0, 0, 0);
  foreach my $v (values(%seq)){
    $Bs += $v->[0];
    $As += $v->[1];
    $Ts += $v->[2];
    $Gs += $v->[3];
    $Cs += $v->[4];
    $Ns += $v->[5];
  }
  return($Bs, $As, $Ts, $Gs, $Cs, $Ns)
}

sub prtHelp {
  print "\nperl $0 options:\n\n";
  print STDERR "### Input reads/sequences (FASTA) (Required)\n";
  print STDERR "  -i <Read/Sequence file>\n";
  print STDERR "    Read/Sequence in fasta format\n";
  print STDERR "  -c [cluster file]\n";
  print STDERR "    cluster file generated by corset\n";
  print STDERR "  -m <Min Sequence Length to Stat:200>\n";
  print STDERR "    Min Sequnece Length used in Stat\n";
  print STDERR "  -g <step length used to group the sequence:100>\n";
  print STDERR "    step length used to group the sequence\n";
  print STDERR "\n";
  print STDERR "### Other options [Optional]\n";
  print STDERR "  -h | -help\n";
  print STDERR "    Prints this help\n";
  print STDERR "  -f | -fileBase <Output file base name>\n";
  print STDERR "    output will be stored in the file using the name as base \n";
  print STDERR "    default: using the fasta file name as the base name for all output file\n";
  print STDERR "\n";
}

sub prtError {
  my $msg = $_[0];
  print STDERR "+======================================================================+\n";
  printf STDERR "|%-70s|\n", "  Error:";
  printf STDERR "|%-70s|\n", "       $msg";
  print STDERR "+======================================================================+\n";
  prtUsage();
  exit;
}

sub prtUsage {
  print STDERR "\nUsage: perl $0 <options>\n";
  prtHelp();
}
